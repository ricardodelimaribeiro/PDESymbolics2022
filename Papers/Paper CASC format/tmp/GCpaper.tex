\documentclass{article}
\begin{document}


{Algorithmic detection of conserved quantities for finite-difference schemes{Supported by King Abdullah University of Science and Technology (KAUST) baseline funds and KAUST OSR-CRG2021-4674.}}
{Diogo A. Gomes{1}{0000-0002-3129-3956} 
	Friedemann Krannich{1}{1111-2222-3333-4444} 
	Bashayer Majrashi{1}{0009-0008-3677-8064 } 
	Ricardo de Lima Ribeiro{1}{0000-0002-2707-2210}}
{D.A. Gomes et al.}
{King Abdullah University of Science and Technology (KAUST), AMCS/CEMSE Division, Thuwal 23955-6900, Saudi Arabia	{{diogo.gomes,friedemann.krannich,bashayer.majrashi, ricardo.ribeirokaust.edu.sa}}


	Many partial differential equations (PDEs) admit conserved quantities like mass or energy. These quantities are often essential for establishing well-posedness results. When approximating a PDE with a finite-difference scheme, it is crucial to determine whether related discretized quantities remain conserved over time by the scheme. Such conservation may ensure the stability of the numerical scheme. We present an algorithm for verifying the preservation of a polynomial quantity under a polynomial finite-difference scheme. Our schemes can be explicit or implicit, have higher-order time and space derivatives, and an arbitrary number of variables. Additionally, we introduce an algorithm for finding conserved quantities, given a scheme. We illustrate our algorithm with several finite-difference schemes. Our approach incorporates parametric G bases to handle parameters, ensuring accurate computation of conserved quantities.
	
	
	{Symbolic computations  Finite-difference schemes  Discrete variational derivative  Discrete partial variational derivative  Conserved quantities  Implicit schemes  Explicit schemes  Parametric Groebner basis.}


Introduction.


{  add 
Comprehensive Gr{}bner Systems 2222
}
In many partial differential equations (PDEs), conserved integral quantities play a crucial role, as they often represent properties of physical significance, such as energy or mass. For example, the advection equation preserves energy and the heat equation conserves mass. 
Since closed-form solutions for these PDEs are often unavailable, finite-difference schemes serve as a practical numerical alternative. Hence, it becomes imperative to determine whether the chosen scheme preserves these conserved quantities. This information is not only valuable for gauging the accuracy of the approximation, but also vital for evaluating its stability. Automating conservation computations in computer algebra systems streamlines the process, saves time, enhances accuracy, and may create new research opportunities.

{  [1] and [1] need domains and ranges, also explain that divergence is only in [1]}

Conserved quantities correspond to conservation laws, admitted by the PDE. A conservation law [1] is an equation of the form

	{ }{ t}[u]+{div} [u]=0

holding for all solutions [1] of the considered PDE,
that induces the conserved quantity [1] as

	{d}{dt} [u]= D_t[u]=- D_x[u]=0

assuming periodic boundary conditions in [1].

There is a similar formulation for
for conservation laws for finite difference schemes of a PDE  where the derivatives in the preceding identity are replaced by shifts [1].  . As a result, standard approaches for constructing schemes with conservation involve either discretizing the continuous conservation law or finding multipliers for the scheme [1].
Alternatively, 
to verify that a particular scheme admits conservation laws, we can use the  discrete Euler operator [1]. Kupershmidt [II. Theorem 31]{kupershmidt85} discovered that an equation represents a discrete conservation law if and only if it is in the kernel of the discrete Euler operator
This strategy has been employed in recent studies, such as by Dorodnitsyn et al. for developing a shallow water equation scheme that preserves energy [1], and by Cheviakov et al. for creating linear and nonlinear wave equation schemes that admit discrete analogs of continuous conservation laws [1].
These strategies also apply to continuous or semi-discretized PDEs. Algorithms using multipliers and the Euler operator for PDEs were developed and implemented by Cheviakov [1]. Hereman et al. [1] proposed an algorithm for computing conserved densities for semi-discretized PDE schemes with first-order time derivatives, using scaling symmetries and the discrete Euler operator. Gao et al. extended this algorithm to first-order time-explicit [1] and time-implicit schemes [1].
Bihlo et al. [1] used another approach and derived finite-difference schemes for the shallow water equations, that are symmetry-invariant on an adaptive mesh and then analyzed them regarding conserved quantities.

In this paper, we present an algorithm that verifies if a quantity is conserved over time under a given scheme. Our approach diverges from previous methods, as we do not attempt to construct discrete [1] and [1] using the scheme, but rather check if a given discrete [1] is conserved over time under the scheme. Typically, conserved quantities involve integral expressions or their discrete analogs, such as sums. Gomes et al. proposed algorithms for simplifying sums [1] and developed algorithms for detecting conserved quantities in PDEs and semi-discretized schemes [1]. We review these techniques in Section [1].
To generalize these methods for cases without summing over all arguments of the involved functions, we introduce the discrete partial variational derivative (Section [1]). Our main contribution is an algorithm for verifying the conservation of a quantity under a numerical scheme. Gerdt [1] demonstrated that the quantity is conserved if its discrete time derivative belongs to the difference ideal generated by the scheme. However, some quantities may add only to a constant and be trivially preserved without being part of the difference ideal. Furthermore, Gerdt's algorithm may not always terminate, as the Gr{}bner basis for the difference ideal might be infinite.
We address these issues by combining the discrete partial variational derivative with a polynomial ideal (instead of a difference ideal) having a finite Gr{}bner basis (Section [1]). Our algorithm is applicable to schemes that are explicit and implicit in time, can handle schemes with multiple higher-order time and space derivatives, multiple space dimensions, systems of equations, and schemes with parameters.
As the process of finding conserved quantities involves polynomial division, special care must be taken to ensure that the division is performed correctly with respect to the parameters. We employ parametric Gr{}bner  bases, which are crucial for the proper treatment of parameters in our algorithm, see Section [1]
 We have implemented this algorithm as a part of a {Mathematica} package [1]{The code is available upon request. For access, contact ricardo.ribeirkaust.edu.sa.}. Our examples include Burgers equation and a PDE system related to mean-field games (Section [1]). In these examples, 
 we show that our code detects conserved quantities and can be used to select suitable schemes for time-implicit and time-explicit discretizations. 

Preliminaries.




In this section, we introduce the concept of discrete torus and discrete variational derivatives, and discuss their properties and applications in simplifying sums. 
These definitions are essential for the analysis of methods presented in the rest of the paper.
Here, we 
discuss the connection between discrete functionals and discrete variational derivatives and present examples that illustrate how to simplify sums using this approach.
We follow the ideas in [1].
In this paper, subscripts denote coordinate or tuple indices, and superscripts denote sequence indices.
To avoid boundary terms, we work with periodic functions in [1].

When discretizing PDEs using finite difference schemes, we need to work with functions defined on discrete sets. For instance, periodic functions in [1] can be replaced by functions defined on the discrete torus, which will be introduced in the following discussion.

	
	Let [1], [1] and [1] be positive integers. The {discrete torus} is the set [1]. Define the space
	
		{P}({I},{R}^m):=\ |:{I}\mathbb{R}^m.
Functions in [1] extend periodically to [1].

We introduce discrete functionals in the previous function space. These functionals are the analog of integral functionals for discrete approximations of functions.

	
	The space of functionals [1] (not necessarily linear) on [1] is
	
		{F}({P}({I},{R}^m)):= \{{J}:{P}({I},{R}^m) {R}\Bigg|\mathcal{J}[u]=_{n\mathcal{I}}F_n[u],
		{ where }
		F_n[u]=G(u(n+e^1),u(n+e^2),,u(n+e^k))
		{ and }^1,,e^k\subset{{Z}}^d,\text{G is smooth}
		\}.

In the previous definition, [1] are not necessarily unit vectors and may vary between functionals.

	
	Let [1] and
	[1].

The discrete variational derivative is a useful tool for simplifying sums.
Let [1], [1] and [1]. Define

	D{J}[u](v):={d}{d}{J}[u+ v]|_{=0}.
In [1], we shift the indices because of the periodicity of [1] and [1],

		D{J}[u](v)={d}{d}{J}[u+ v]|_{=0}={d}{d}_{n\mathcal{I}}F_n[u+ v]|_{=0}
		=_{n\mathcal{I}}{d}{d}G(u(n+e^1)+ v(n+e^1),,u(n+e^k)+ v(n+e^k))|_{=0}
		=_{n\mathcal{I}}D_1G(u(n+e^1),,u(n+e^k))v(n+e^1)
		++D_kG(u(n+e^1),,u(n+e^k))v(n+e^k)
		=_{n\mathcal{I}}D_1G(u(n),u(n+e^2-e^1),,u(n+e^k-e^1))v(n)
		+D_2G(u(n+e^1-e^2),u(n),,u(n+e^k-e^2))v(n)
		++D_kG(u(n+e^1-e^k),u(n+e^2-e^k),,u(n))v(n)
		=_{n\mathcal{I}}(D_1G(u(n),u(n+e^2-e^1),,u(n+e^k-e^1))
		+D_2G(u(n+e^1-e^2),u(n),,u(n+e^k-e^2))
		++D_kG(u(n+e^1-e^k),u(n+e^2-e^k),,u(n)))v(n)
		=:_{n\mathcal{I}}{V}({J})[u](n)v(n).
The operator [1] can be viewed as a representation of the derivative [1] with respect to the [1] inner product [1], leading to the following definition.

	[1] is the {discrete variational derivative} of [1].

Because we assume all related functions are smooth, the discrete variational derivative always exists.

Now, we return to Example [1] and compute
	
		D{J}[u](v)={d}{d}{J}[u+ v]|_{=0}={d}{d}_{n\mathcal{I}}F_n[u+ v]|_{=0}
		=_{n\mathcal{I}}{d}{d}G[u(n+1)+ v(n+1),u(n)+ v(n)]|_{=0}
		=_{n\mathcal{I}}2(u(n+1)-u(n))v(n+1)+(-2)(u(n+1)-u(n))v(n)
		=_{n\mathcal{I}}2(u(n)-u(n-1))v(n)+(-2)(u(n+1)-u(n))v(n)
		=_{n\mathcal{I}}(2(u(n)-u(n-1))+(-2)(u(n+1)-u(n)))v(n)
		=_{n\mathcal{I}}(-2u(n+1)+4u(n)-2u(n-1))v(n)
		=_{n\mathcal{I}}{V}({J})[u](n)v(n).
Thus, [1].

The algorithms for the simplification of sums presented in [1] relies on the following result, which 
provides a criterion to compare functionals and evaluate if they represent the same quantity.


	Let [1]. If [1] for all [1] and if there exists [1] such that [1], then
	[1]
	for all [1].
	Conversely,
	[1]
	for all [1], if [1].


	We have
	
		({J}-{{J}})[u]=({J}-{{J}})[u]-({J}-{{J}})[u_0]
		=_{0}^{1}{d}{d}({J}-{{J}})[u_0+(u-u_0)]\lambda
		=_{0}^{1}{V}({J}-{{J}})[u_0+(u-u_0)](u-u_0)\lambda=0
	
	and hence [1].

We use Theorem [1] to determine whether different sums represent the same quantity.

	Let [1] and consider the functionals
	
		{J}[u]:=_{n\mathcal{I}}u(n)u(n+1){ and }
		{{J}}[u]:=_{n\mathcal{I}}u(n-2)u(n-1).
	It is clear that [1] and [1] represent the same quantity (by shifting [1]). We confirm this, using the discrete variational derivative:
	
		D({J}-{{J}})[u](v)=
		=_{n\mathcal{I}}(u(n+1)+u(n-1)-u(n+1)-u(n-1))v(n)=0.
	Hence, [1] and [1]. Therefore, both functionals represent the same quantity.



	Let [1] and [1]. It may not be obvious, that
	
		_{n_1,n_2}u(n_1,n_2-2)^4 - 3 u(n_1,n_2-2)^3 u(n_1+1,n_2-2) + 
		u(n_1,n_2) u(n_1+1,n_2)^3 + 3 u(n_1,n_2-2)^2 u(n_1+1,n_2-2)^2 -
		u(n_1,n_2-2) u(n_1+1,n_2-2)^3
		- u(n_1, n_2)^4 +
		3 u(n_1,n_2)^3 u(n_1+1,n_2)- 3 u(n_1,n_2)^2 u(n_1+1,n_2)
		-3 u(n_1,n_2-2)^2 u(n_1+1,n_2-2)^2+ 3 u(n_1,n_2)^2 u(n_1+1,n_2)=0.
	We confirm this by computing the discrete variational derivative and noticing that the expression is [1] for [1].



The discrete partial variational derivative.




In this section, we introduce the concept of the discrete partial variational derivative, a generalization of the discrete variational derivative for cases where one or several arguments of the indices are kept constant. This generalization provides a more flexible approach to handling various problems in conservation laws for finite-difference schemes, addressing challenges and limitations of the traditional discrete variational derivative. The main result of this section is Theorem [1], which gives a criterion for equality of two functionals based on their discrete partial variational derivatives."

Let [1] be the variables for the functions in [1]. We call [1] the space variables. Let [1] and call [1] the time variables. For generality, we consider the vectorial time case, while later in this paper, we focus specifically on the case when [1].
The analog to Definition [1] is the following. 

	Let [1].
	Functions in [1] extend to [1] through  periodicity in the space variables.
	Let [1].

We can regard [1] as the set of functions depending in space and time and [1] as the functions depending only on time. 

Next, we examine functions that involve summation only over spatial variables, extending the concept presented in Definition [1].

	
	The space of functions [1] is
	
		{F}({P}({I}\mathbb{N}^l,{R}^m),{D}({N}^l)):=	
		\{{J}:{P}({I}\mathbb{N}^l)\mathcal{D}({N}^l) |\mathcal{J}[u](t)=_{n\mathcal{I}}F_{(n,t)}[u],
		{where } F_{(n,t)}[u]=G(u((n,t)+e^1),u((n,t)+e^2),,u((n,t)+e^k)),
		{and }
		^1,,e^k\subset{{Z}}^{d+l},{G is a polynomial in k variables}\}.
	Here, [1].


Here, all quantities, whose conservation in time we check, are functions [1]. 
Let [1]. Using the Kronecker delta [1], we rewrite

	{J}[u](t_1,,t_{l})
	=_{{n}\mathcal{I}\mathbb{N}^l}F_{{n}}[u]_{(t_1,,t_{l})}(s_1,,s_l).
Let [1], then


	D^l{J}[u](v)(t_1,,t_{l}):={d}{d}{J}[u+ v]|_{=0}(t_1,,t_{l})
	=_{{n}}D_1G(u({n}+e^1),,u({n}+e^k))_{(t_1,,t_{l})}(s_1,,s_l)v({n}+e^1)
	+D_2G(u({n}+e^1),,u({n}+e^k))_{(t_1,,t_{l})}(s_1,,s_l)v({n}+e^2)+
	+D_kG(u({n}+e^1),,u({n}+e^k))_{(t_1,,t_{l})}(s_1,,s_l)v({n}+e^k)
	=_{{n}}D_1G(u({n}),,u({n}+e^k-e^1))_{(t_1,,t_{l})}(s_1-e^1_{d+1},,s_l-e^1_{d+l})v({n})
	+D_2G(u({n}+e^1-e^2),,u({n}+e^k-e^2))_{(t_1,,t_{l})}(s_1-e^2_{d+1},,s_l-e^2_{d+l})v({n})+
	+D_kG(u({n}+e^1-e^k),,u({n}))_{(t_1,,t_{l})}(s_1-e^k_{d+1},,s_l-e^k_{d+l})v({n})
	=_{{n}}(D_1G(u({n}),,u({n}+e^k-e^1))_{(t_1+e^1_{d+1},,t_{l}+e^1_{d+l})}(s_1,,s_l)
	+D_2G(u({n}+e^1-e^2),,u({n}+e^k-e^2))_{(t_1+e^2_{d+1},,t_{l}+e^2_{d+l})}(s_1,,s_l)+
	+D_kG(u({n}+e^1-e^k),,u({n}))_{(t_1+e^k_{d+1},,t_{l}+e^k_{d+l})}(s_1,,s_l))v({n})
	=:_{{n}}{V}^l({J})[u]({n},t)v({n}).


[1] is the {discrete partial variational derivative} of [1].
	Note that [1].


	
	The discrete partial variational derivative of 
	
		{J}[u](t)=_nu(n,t+1)-u(n,t)=_{n,s}(u(n,s+1)-u(n,s))_t(s)
	
	is [1], because
	
	
		D^1({J})[u](v)(t)
		={d}{d} _{n,s}((u(n,s+1)+ v(n,s+1))-(u(n,s)+ v(n,s)))_t(s)
		=_{n,s}v(n,s+1)_t(s)-v(n,s)_t(s)=_{n,s}v(n,s)_t(s-1)-v(n,s)_t(s)
		=_{n,s}(_{t+1}(s)-_t(s))v(n,s)=_{n,s}{V}^1({J})(n,s,t)v(n,s).
	


	In our {Mathematica} implementation, Example [1] is computed by
		
	
		[moredefined={variables, expression, PartialDVarD}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\},
  "timeVars"[1]\}|>
  PartialDVarD[variables][u[n,t+1]-u[n,t]]
  

		{Output}
  -KroneckerDelta[t]+KroneckerDelta[1+t]

	

We have a result similar to Theorem [1] for the discrete partial variational derivative:

	Let [1]. If [1] for all [1] and if there exists [1] such that [1], then
	[1]
	for all [1].
	Conversely,
	[1]
	for all [1], if [1].

The proof is similar to the proof of Theorem [1].

Difference schemes and algebra.



In this section, we formally define numerical schemes and introduce the necessary tools from difference algebra for our algorithm.
Throughout this paper, we assume that there is only one time variable [1] ([1]).

	The {space of schemes} is
	
		{S}({P}({I}\mathbb{N},{R}^m),{P}({I}\mathbb{N},{R})):=
		\{H:{P}({I}\mathbb{N},{R}^m)\mathcal{P}({I}\mathbb{N},{R})\Bigg|
		H[u](n,t)=H(u(n+{e}^1,t+{l}^1),,u(n+{e}^r,t+{l}^r)),
		{where }
		\tilde{e}^1,,{e}^r\subset{{Z}}^d,\{{l}^1,,{l}^r\subset{{Z}},
		{H is a polynomial in r variables}
		\}.
	A {scheme} is a set of functions
	
		^1,,H^i\subset{S}({P}({I}\mathbb{N},{R}^m),{P}({I}\mathbb{N},{R}))
	
	that represent the equations [1] for [1], holding pointwise for all points in [1].

If a scheme contains a single function [1], we call [1] the scheme. Sometimes, we also call the expression [1] the scheme.

	In our examples, we only consider finite-difference schemes with fixed step sizes [1]. However, our algorithms and our code handle parameters. Hence, our results can be generalized to schemes with other step sizes.


	
Consider the heat equation	[1] [1].  A possible scheme is
[1].
A solution of the corresponding numerical approximation is a function [1], that satisfies
[1]
for all [1] and [1]. 



	A scheme [1] given by
	[1]
	is in {time-explicit form} if we can rewrite the previous equation (eventually translating the scheme) as
	[1]
	for [1]
	with [1]. We call [1] the right-hand side of [1].


	Consider the forward-difference scheme for the heat equation in Example [1]. 
	This scheme is in time-explicit form with right-hand side
	[1].

{Difference ideals.}
Following Gerdt [1], we now introduce difference ideals and how we use them in our algorithm.

	Let [1]. The {shift} in the [1]-th coordinate for [1] by [1] is
	
		_i^k u_j(n,t):=u_j(n_1,,n_{i-1},n_i+k,n_{i+1},,t)
	
	understanding that [1] shifts the time variable.


	The {set of all possible shifts} [1] is
	
		:=\sigma_1^{k_1}\cdots\sigma_{d+1}^{k_{d+1}}|_1,,k_{d+1}{{Z}}.

We now construct the difference ideal containing the scheme.

	
	Let [1] be the field generated by [1] and the variables [1]. Let [1] be the polynomial ring over the field [1] and the variables [1] for [1] and [1].
	A set [1] is a {difference ideal} if
	[1] implies [1];
	[1] implies [1] and
	[1] implies [1].


	[1] is the smallest difference ideal containing the scheme [1].



A solution of a numerical scheme is a function, [1], that makes all translations of the scheme vanish. Hence, every element of the difference ideal generated by the scheme vanishes under [1]. As a result, every element of the difference ideal generated by the scheme vanishes under [1]. If the polynomial associated with the discrete time derivative  [1]
belongs to the ideal [1], the corresponding functional vanishes. 
 Gerdt introduced the concept of a standard  Gr{}bner basis for the ideal [1], which might not be finite. To address this issue, we use polynomial algebra instead of difference algebra and a smaller polynomial ideal contained within the difference ideal that has a finite standard basis.
 
 However, ideal membership is not  a necessary condition for conservation. Some functions, [1],
 may have sums that add to zero even if they do not belong to the difference ideal. Thus, we combine the discrete partial variational derivative with polynomial ideals. This idea is implemented in Algorithm [1] in Section [1].












  
Parametric Groebner Systems.




In this section, we delve into essential concepts for 
parametric polynomial ideals. These include parametric rings, 
specialized ideals, and comprehensive Gr{}bner systems, which are built upon 
Gr{}bner basis theory. 
We discuss the benefits of using comprehensive Gr{}bner systems 
and how they help address problems that occur when not using them. 
Furthermore, we expand on the ideal membership problem to encompass parametric ideals.




    Let [1] be a field. The ring of parametric polynomials
    [1] is a ring of polynomials in the variables [1] with coefficients that are polynomials
    in the ring [1]. 
    For simplicity we denote this ring by [1].



    Let [1] be an algebraically closed field extension of [1] and let [1] be a ring homomorphism. [1] is a specialization given by a polynomial evaluation on the parameters and an identity on the variables, i.e., 
    for [1]
    [1] is given by [1], for some [1].
    

It is easier to think about specializations as a choice of parameters. 

Comprehensive Gr{}bner systems extend Gr{}bner basis to 
parametric polynomials and have diverse practical applications in 
algebraic geometry, combinatorics, coding theory, computer-aided design, and robotics.

    Let [1] be a finitely generated, nonzero ideal in the ring [1] with a fixed monomial order [1] on the variables. 
    Let [1] be a family of locally closed sets that forms a partition of [1] 
    , such that the disjoint union [1], and [1] 
    be a family of subsets in [1].
    The system, 
	[1].

    is called a comprehensive Gr{}bner system (CGS) of [1]
     if for all specializations [1] 
     is a Gr{}bner basis of the specialized ideal [1].
     Where each pair [1] is called a branch. 

Here, the notation [1], with [1], is the specialization [1]
of each [1] such that  [1]
and  [1] stands for a specialization given by [1] 
for [1].

In this paper, we choose [1] to be of the form 
[1].
Where [1] and [1] is a Variety.

A proof of existence and the first algorithm to compute the (CGS) were introduced by Volker Weispfenning.

    Let [1]. The corresponding comprehensive Gr{}bner system exists.[1]

We use our implementation of a parametric Buchberger's algorithm to compute (CGS). 
This is illustrated in the following examples.

    Let [1] be the ideal generated by 
    [1].
    The comprehensive Gr{}bner system of [1] with a Lexicographic order [1] is:
    {  we use our code here}

The idea of a comprehensive Gr{}bner system is to provide a "parameter sensitive Gr{}bner basis".
It branches the cases of the parameters that affect leading terms. For instance, in the previous
example if [1] then the leading term [1] vanishes which leads to a different Gr{}bner basis. Therefore,
the (CGS) considers cases of the leading coefficients parameters Vanishing.


    Let [1] be the ideal generated by 
    [1].
    The comprehensive Gr{}bner system of [1] with a Lexicographic order [1] is:
    
    {  we use our code here}



    If a polynomial ideal contains a nonzero constant polynomial, then it is called a unit ideal [1].
   Unit ideals can generate all polynomials in the ring, so [1].
    As a convention the Gr{}bner basis of such ideals is [1].

   
Issues arise when computing the Gr{}bner basis of [1] without considering the parameters.
In practice, to compute the Gr{}bner basis without considering the parameters, we assume non-zero parameters by default.
This assumption guarantees a Gr{}bner basis only for one set of specializations [1]. i.e., 
[1] is a Gr{}bner basis of the specialized ideal [1] only for [1].
Next, we show the impact of this assumption.

     In general [1] is not necessarily a Gr{}bner basis.
    
        
        Let [1]. The corresponding Gr{}bner basis 
           is [1]. Consider 
           the specialization [1] given by [1].
           The set [1] is not a Gr{}bner basis.
		   This can be shown by the Buchberger Criterion (see chapter 2 in[1]).

    
     Consequently, the algorithm utilized to resolve the ideal membership 
    problem in chapter 2 of [1] can not be used for all specializations. 
    
    
        
        Consider the ideal [1] in the above example. The corresponding Gr{}bner basis computed under the assumption of non-zero parameters
        is [1] where [1]. 
        Now, it is possible to check if a polynomial [1] belongs to [1] only for [1]     
        because we know that [1] is a Gr{}bner basis. For other specializations such as 
        the specialization [1] given by [1], [1] is not a Gr{}bner basis as shown in the above example. 
        Therefore, we can not proceed with the division algorithm as we can not guarantee unique remainder if we used [1].  
    




Using CGS can resolve these problems. Problem 1 is fixed by the definition of (CGS), as we have [1] a 
 GrA¶bner basis for any specialization [1]. Moreover, 
 to discuses problem 2 we need to look at the parametric ideal membership first.

{  Is this a definition?}
 Consider, [1] we say that [1] under [1], if there exists a specialization 
 [1] such that [1].

To determine if [1] we consider the (CGS) of [1] given [1]. 
We check if [1] for each [1] and [1].
For each [1] we have the corresponding GrA¶bner basis [1]
so we divide [1] by the [1] if the remainder is zero for some [1],
then [1]. Therefore, [1]. However, if the remainder is non-zero for all [1] we conclude that 
[1].


	Let [1] be the ideal generated by 
    [1].
	We will determine if [1].
	We compute the corresponding (CGS)
	{  add example 3}
	First let [1] and [1]. 
	We divide [1] by [1] and we obtain the remainder [1] and 
	since the exists no specialization in [1] such that this remainder is zero we conclude that [1] for
	[1]. Now we repeat the reduction of [1] but with the second GrA¶bner basis [1]. We obtain a zero remainder, which imply that 
	[1] for [1]. Therefore, [1] under a specialization [1].









The time-explicit case.



In this section, we introduce Algorithm [1]  for checking the conservation of a quantity for time-explicit schemes. We discuss the algorithm for general schemes in the next section.

	
	{[1] and [1] right-hand side of a time-explicit scheme}
	{ {True}, if [1] is conserved in time, {False} otherwise }
	
	 Build the discrete time derivative [1]
	
	 Replace all instances of [1] (for [1]) by an appropriate translation of [1]
	
	 Compute the discrete partial variational derivative
	
	 If the result is zero, conservation is {True}, else {False}
	
	{{time-explicit DiscreteConservedQ}}
	

The result of Step 2 exists only at time [1] because all instances of [1] have been replaced. Thus, we do not need any computations of difference ideals or Gr{}bner basis.

	
	We examine the conservation of [1] under the following scheme.
	[1].
	The discrete time derivative (Step 1) is
	
		_{n\mathcal{I}}u(n,t+1)-u(n,t).
	Replace [1] by the right-hand side (Step 2) to get
	
		_{n\mathcal{I}}u(n,t)+(u(n+1,t)-2u(n,t)+u(n-1,t))-u(n,t).
	Then, we compute the discrete partial variational derivative (Step 3), which equals zero. Hence (Step 4), we have conservation.


	
	We verify the result from Example [1], using our implementation in {Mathematica} of Algorithm [1].
	
	
		[moredefined={variables, expression, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1]\},"depVars"[1]\},
  "rhs"[1][n]+(u[n+1]-2u[n]+u[n-1])|>
  DiscreteConservedQ[variables][u[n]]
  

		{Output}
  True

	


{ ADD HERE TIME EXPLICIT EXAMPLE WITH PARAMETERS} 



The general case.



In this section, we present Algorithm [1] that deals with general, not necessarily time-explicit, schemes. We explain its steps in detail below and demonstrate the algorithm in Example [1].

	
	{[1] and [1] }
	{ {True}, if [1] is conserved in time, {False} otherwise }
	
	 Build the discrete time derivative [1]
	
	Translate [1] by subtracting the range of the stencil of the scheme from the range of the stencil of [1]
	
	 Reduce [1] by using {  the Gr{}bner basis} generated by the translated scheme in two different ways
	 (a) Using the lexicographic order
	 (b) Using the explicit elimination order
	
	 Choose the result that admits the least different instances of time
	
	 Compute the discrete partial variational derivative
	
	 Apply Steps 2 to 4 to the result
	
	 If the result is zero, conservation is {True}, else {False}
	
	{{General DiscreteConservedQ}}
	


{Step 1: Build the discrete time derivative.}
We build the discrete time derivative by subtracting [1] from [1]. This task is performed in our code using {TimeDifference}.

	The discrete time derivative for [1] is
	
	
	
		[moredefined={variables, expression, TimeDifference}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\}|>
  TimeDifference[variables][u[n,t]]
  

		{Output}
  <|exp[1]-u[n,t]+u[n,1+t]|>

	

	
{Step 2: Translate the scheme.}
Now, we transition from difference algebra with infinite independent variables to polynomial algebra with finite variables to ensure the finiteness of the Gr{}bner basis. 
Hence, we need to compute a finite number of translations of the scheme and consider every instance of [1] that appears in either the translated scheme or the discrete time derivative as an independent polynomial variable.

	The algorithm treats the discrete time derivative [1]
	as the polynomial [1].

There are several possiblities which translations of the scheme to take as basis for the polynomial ideal. However, an obvious idea is to compute the minimal number of translations of the scheme, such that all instances of [1], that appear in the range of the stencil of the discrete time derivative, also appear in the translated scheme.
This is done by elementwise subtracting the range of the stencil of the scheme from the range of the stencil of the discrete time derivative. Before we define the above translations formally, we give a simple example to illustrate the idea of computing the translations:

	Consider the expression
	
		u(n+3)-u(n-2)
	
	which we want to reduce by the scheme [1]. We compute the translations as described above as
	
		(n+3)-u(n+2),,u(n-1)-u(n-2).
	and see, that the expression indeed reduces to [1] under the scheme.


	Let [1] and
	
		F:
		{P}({I}\mathbb{N},{R}^m)\mathcal{P}({I}\mathbb{N},{R}),
		F[u](n,t)=F(u_1((n,t)+x^1),,u_1((n,t)+x^{k_1}),
		u_2((n,t)+x^{k_1+1}),
		,u_2((n,t)+x^{k_2}),
		,
		u_m((n,t)+x^{k_{m-1}+1}),,u_m((n,t)+x^{k_m}))
	
	
	with [1].
	The {stencil} of [1] is the [1]-tuple of sets of vectors
	
		(\{x^1,,x^{k_1}\},
		\{x^{k_1+1},,x^{k_2}\},
		,
		\{x^{k_{m-1}+1},,x^{k_m}\}).
	The {range} of the stencil of [1] is
	
		([x_1^{k_1 -},x_1^{k_1 +}]\cdots[x_{d+1}^{k_1 -},x_{d+1}^{k_1 +}],
		[x_1^{k_2 -},x_1^{k_2 +}]\cdots[x_{d+1}^{k_2 -},x_{d+1}^{k_2 +}],
			,
		[x_1^{k_m -},x_1^{k_m +}]\cdots[x_{d+1}^{k_m -},x_{d+1}^{k_m +}]
		),
	where [1], [1],
	and [1]. Here, [1] denotes the discrete interval in [1], i.e. [1].

If for any [1] involved we have [1], we write [1] with the convention that [1].  Further, [1] in the translations results in the use of the respective entry of the original scheme without translations.

	Consider the discrete time derivative
	
	[1]
	
	and the scheme
	
	[1].
	
	Then, the stencil of the discrete time derivative equals
	
	[1]
	
	with range
	
	[1].
	
	The stencil of the scheme equals the set of stencils of the equations in the scheme, i.e.
	
	[1]
	
	with range
	
	[1].
	
	Hence, we get the translations for the first equation of the scheme by
	
	
		([0,2][0,1],[0,0] [0,1])-([0,1][0,1],\Big)=([0,1][0,0],\Big)
	
	
	and for the second equation of the scheme by
	
	
		([0,2][0,1],[0,0] [0,1])-(,[0,0] [0,1])=(,[0,0] [0,0]).
	
	Therefore, we translate the first equation of the scheme by [1] and [1] and the second one by [1] to get the translated scheme
	
	
		_1(n+1,t+1)-u_1(n,t),
		u_1(n+2,t+1)-u_1(n+1,t),
		u_2(n,t+1)-u_2(n,t)
		.
	


{Step 3 and 4: Compute Gr{}bner basis and reduce the discrete time derivative.}
{Polynomial ideals and Gr{}bner bases.}
In the previous step, we identified a finite set of polynomials comprising the translated scheme [1] and the discrete time derivative, each containing a finite number of instances of [1]. We now proceed to reduce [1] by treating it as an element of a polynomial ring and performing multivariate polynomial division with respect to the translated scheme. To accomplish this, we adapt the definitions and theorems presented in [1] to suit our specific context.

	Let [1] be as in Definition [1]. Let [1] be the polynomial ring generated by [1] and all instances of [1] that occur in [1].
	We call a set [1] a {(polynomial) ideal} if
	[1] implies [1] and
	[1] implies [1].


	We denote by [1] the smallest (polynomial) ideal containing [1].

Given the ideal [1] and the discrete time derivative [1], we want to determine if [1] or if we can write [1] in a simpler form, using [1].
Hence, using multivariate polynomial division, we search for [1] such that

	{T}=p^1H^1++p^rH^r+p^{r+1}.
Unfortunately, the resulting remainder [1] may not be unique [page 14, Example 1.2.3]{hibi13}, i.e. non-zero, although [1] belongs to [1]. 
Replacing [1] by a Gr{}bner basis for the ideal [1] guarantees the uniqueness of the remainder of the polynomial division. 
Contrary to the standard basis for the difference ideal that Gerdt's algorithm computes, a Gr{}bner basis for the polynomial ideal always exists and is finite.
A Gr{}bner basis is defined up to the order of the monomials involved, so, depending on the order, we get different remainders of the polynomial division.

{Polynomial reduction.}
In Algorithm [1], we employ two monomial orders: (a) the lexicographic order and (b) an experimental elimination order. To reduce [1], we first compute the Gr basis of [1] with respect to the chosen monomial order and subsequently calculate the remainder resulting from the polynomial division of [1] with respect to this Gr basis.

The lexicographic order (a) is induced by the time-explicit ordering of the instances of [1], giving greater importance to instances at later times over those at earlier times. For the elimination order (b), we initially order all instances of [1] based on a predefined ordering. By default, our code employs the time-explicit ordering, but other options, such as implicit or user-defined orderings, can also be used. We then attempt to sequentially eliminate the instance with the highest ordering from the discrete time derivative, utilizing the elimination order induced by a weight-matrix. This elimination may not always be feasible, resulting in an unchanged discrete time derivative. In such cases, we repeat the process for the instance at the second latest time and continue until all instances of [1] have been eliminated.

It should be noted that the elimination order (b) is experimental in nature, as its weight-matrix lacks full rank and therefore does not induce a total order on the set of monomials. Finally, we select the result with the fewest distinct time instances from the two remainders produced by the lexicographic order (a) and the elimination order (b).

 {Step 5 to 7: Compute the discrete partial variational derivative and reduce again.}
In the next step, we take the resulting expression and compute its discrete partial variational derivative. Then, we repeat Step 2 to Step 4 applied to the discrete partial variational derivative.

	
	To illustrate Algorithm [1], we use the setting of Example [1].
	We compute the discrete time derivative (Step 1)
	
		{T}=_{n\mathcal{I}} u(n,t+1)-u(n,t).
	For the translations (Step 2), the stencil of the scheme
	[1]
	
	is
	[1]
	
	with range [1].
	The discrete time derivative has stencil [1] 
	and range [1].
	The translations are
	
	
		([0,0][0,1])-([-1,1][0,1])=([1,-1][0,0])=(\times[0,0])
	
	
	which results in no translations, as the range of the stencil of the scheme is greater than the range of the stencil of the discrete time derivative.
	Hence, the Gr{}bner basis (Step 3) coincides with the original scheme for both monomial orders.
	The reduction using the lexicographic monomial order yields as remainder
	
		u(n-1,t)-2u(n,t)+u(n+1,t).
	For the reduction using the elimination order, we first eliminate [1] and then the remaining instances of [1].
	The elimination order yields the same remainder as the lexicographic order. Hence, we do not check for the number of instances of time (Step 4).
	We calculate the discrete partial variational derivative (Step 5) of
	
		_{n\mathcal{I}}u(n-1,t)-2u(n,t)+u(n+1,t)
	
	that equals [1].
	Hence, repeating the above procedure (Step 6) becomes unnecessary.
	Therefore, (Step 7) we see that the scheme conserves the quantity.


	We verify our result from Example [1], using {DiscreteConservedQ}, which detects automatically if the scheme is time-explicit or if
	 the general setting should be applied.
	
	
		[moredefined={variables, expression, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\},
  "scheme"[1][n,t+1]-u[n,t]
  -(u[n+1,t]-2u[n,t]+u[n-1,t])|>
  DiscreteConservedQ[variables][u[n,t]]
  

		{Output}
  True

	


The algorithm is designed to identify conservation, but it cannot definitively confirm the absence of conservation. Therefore, a {False} result should be interpreted as the algorithm being unable to detect conservation, rather than an absolute assertion of non-conservation. The reason for this is that we are working with a Gr basis that does not generate the full difference ideal. 


{  add an example with parameters}


A basis for conserved quantities.



So far, we have discussed how to check if a quantity is preserved in time under a scheme. But it is also desirable to have a systematic way to find conserved quantities, given a scheme.
Algorithm [1] finds, for a time-explicit scheme, a basis for conserved quantities that are generated by monomials up to a degree. 

	
	{right-hand side set of polynomials [1] ofa time-explicit scheme, list of {generators}, {degree} of polynomials }
	{basis of conserved quantities}
	
	 Construct all monomials combined from the {generators} up to the total {degree}
	
	 Form linear combinations of all monomials with undetermined coefficients
	
	 Compute the discrete time derivative and substitute in the appropriate right-hand side(s) polynomials of the scheme
	
	Compute the discrete partial variational derivative
	
	 Simplify the expression and apply the undetermined coefficients method to find coefficients that make the result vanish
	
	{{FindDiscreteConservedQuantityBasis}}
	

We have implemented this algorithm in {FindDiscreteConservedQuantityBasis}.

In the context of the heat equation from Example [1], we aim to find a basis for conserved quantities generated by [1] and [1] with a maximum degree of 3.
	
	
		[moredefined={variables, FindDiscreteConservedQuantityBasis}]{Input}
  variables=<|"indVars"[1]\},"depVars"[1]\},
  "rhs"[1][n]+u[n+1]-2u[n]+u[n-1]|>
  FindDiscreteConservedQuantityBasis[variables]
  [<|"degree"[1]3,"generators"[1][n],n|>]
  

		{Output}
  [n],nu[n]

	
The first conserved quantity corresponds to mass conservation and the second to center of mass conservation. 

Examples and applications.



We demonstrate our code's capabilities using two examples: the inviscid Burgers equation and a mean-field game system. 
Through these examples, we examine different discretizations, evaluate their conservation properties, and identify conserved quantities.
Although the examples presented feature only first-order time derivatives, the algorithm can handle PDEs with derivatives of any order.

{Burgers equation.}
In the first example, we focus on the inviscid Burgers equation, a well-known PDE with the form [1] [1]. 
This PDE preserves the total mass [1].
Our first example demonstrates how the code verifies mass conservation by a forward-difference discretization.
Next, we demonstrate the algorithm's ability to find a mass-preserving scheme by investigating conservation properties under a class of schemes involving a parameter.
Finally, we explore time-implicit versions of the schemes and their conservation properties.

The inviscid Burgers equation is the PDE [1] [1] in one space dimension. Any function of [1] is a conserved quantity. We search for discretizations preserving [1].

	We check for conservation of mass using a forward-difference discretization:
	
	
		[moredefined={variables, expression, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\},
  "scheme"[1][n,t+1]-u[n,t]
  -u[n,t](u[n+1,t]-u[n,t])|>
  DiscreteConservedQ[variables][u[n,t]]
  

		{Output}
  False

	

For finding a scheme that preserves mass, we check for conservation under a class of schemes with a parameter.

	We discretize [1] with a three-point stencil with a parameter [1].
	
	
		[moredefined={variables, expression, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\},
  "pars"[1]\},"scheme"[1][n,t+1]-u[n,t]
  -u[n,t](a(u[n+1,t]-u[n,t])
  +(1-a)(u[n,t]-u[n-1,t]))|>
  DiscreteConservedQ[variables][u[n,t]]
  

		{Output}
  False		a==0||a==1||-1+2a[1]0
  True		a=={1}{2}
  

	
The conservation property holds when [1], which corresponds to the central difference case.

So far, we have only seen schemes that are in time-explicit form, but our algorithm allows also for general schemes:

	We consider the scheme from the previous example but in the time-implicit version.
	
	
		[moredefined={variables, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1]\},
  "pars"[1]\},"elimOrder"[1]"implicit",
  "scheme"[1][n,t+1]-u[n,t]-u[n,t+1]
  (a(u[n+1,t+1]-u[n,t+1])
  +(1-a)(u[n,t+1]-u[n-1,t+1]))|>
  DiscreteConservedQ[variables][u[n,t]]
  

		{Output}
  False		a==0||a==1||-1+2 a[1]0
  True		a=={1}{2}


	


{Conserved quantities for a mean-field game.}
We analyze the conserved quantities preserved by the discretization of a PDE system in the context of mean-field games.
The examples showcase our algorithm's effectiveness in identifying conserved quantities for various discretization schemes, including time-explicit, time-implicit, and mixed schemes.

	In [1], Gomes et al. derived the following system
	
		v_t+({v^2}{2}-{m^2}{2})_x=0,
		m_t-(vm)_x=0.
	This system admits the conserved quantities [1] and [1].
	Because this system was derived from a forward-forward mean-field game, we discretize it forward in time. We check with our code if the scheme admits the same preserved quantities as the continuous system:
	
	
		[moredefined={variables, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1],m,
  "scheme"[1][n,t+1]-v[n,t]
  +({v[n+1,t]}{2}-{m[n+1,t]}{2})/2-({v[n,t]}{2}-{m[n,t]}{2})/2,
  m[n,t+1]-m[n,t]-m[n+1,t]v[n+1,t]+m[n,t]v[n,t]|>
  DiscreteConservedQ[variables][[n,t],m[n,t]]
  

		{Output}
  True

	
We replicate this result, observing that the scheme used here is time-explicit:
	
	
		[moredefined={variables, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1]\},"depVars"[1],m,
  "rhs"[1][n]-({v[n+1]}{2}-{m[n+1]}{2})/2
  +({v[n]}{2}-{m[n]}{2})/2,m[n]+m[n+1]v[n+1]-m[n]v[n]|>
  DiscreteConservedQ[variables][[n],m[n]]
  

		{Output}
  True

	
	Those are the only conserved quantities for this scheme, which are polynomials up to degree 4 in [1] and [1].
	
	
		[moredefined={variables, PartialDVarD, FindConservedQuantityBasis}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1],m,
  "eqRhs"[1]0.5({v[n+1,t]}{2}-{m[n+1,t]}{2})
  -0.5({v[n,t]}{2}-{m[n,t]}{2}),
  m[n+1,t]v[n+1,t]-m[n,t]v[n,t]|>
  FindConservedQuantityBasis[variables]
  [<|"degree"[1]4,"generators"[1][n,t],m[n,t]|>]
  

		{Output}
  [n,t],v[n,t]

	


	The related backward-forward system reads
	
		-v_t+({v^2}{2}-{m^2}{2})_x=0,
		m_t-(vm)_x=0.
	This system admits the same conserved quantities as the forward-forward system, but we approximate it explicitly in time for [1] and implicitly for [1].
	Our code can handle this setting by specifying an order for variable elimination, using an explicit monomial order for [1] and an implicit order for [1]:
	
	
		[moredefined={variables, DiscreteConservedQ}]{Input}
  variables=<|"indVars"[1],t,"depVars"[1],v,
  "elimOrder"[1]"explicitimplicit",
  "scheme"[1]-(v[n,t+1]-v[n,t])
  +({v[n+1,t+1]}{2}-{m[n+1,t+1]}{2})/2
  -({v[n,t+1]}{2}-{m[n,t+1]}{2})/2,
  m[n,t+1]-m[n,t]-m[n+1,t]v[n+1,t]+m[n,t]v[n,t]|>
  DiscreteConservedQ[variables][[n,t],m[n,t]]
  

		{Output}
  True

	

Possible extensions and concluding remarks.


 Polynomial treatment of non-polynomial expressions.


It may be possible to extend our methods to non-polynomial PDEs and schemes. In this case, non-polynomial expressions can be handled by writing them in polynomial form.
{Translate the scheme more accurately.}
In our elimination procedure, we work with a specific polynomial ideal that is a subset of the difference ideal generated by the scheme. However, it could be necessary to translate the scheme more than we did in our algorithm to get cancellation. Therefore, flexible methods to determine the translations of the scheme are desirable.
Experimental check of conservation.


An experimental approach, that gives a hint, if a quantity is conserved, and that can refute conservation, is the following:
We fix [1] and [1]. Then, we generate experimental initial data by randomly sampling [1] values, with every value corresponding to an instance of [1] for [1]. Afterward, we calculate [1] for all [1], using the scheme. With this values, we explicitly calculate the value of the discrete time derivative.
If the discrete time derivative is zero for several different samples of initial data, we might have conservation on the discrete level. Otherwise, if we find initial data such that the discrete time derivative is not zero, we can refute conservation.
Discrete conserved quantities that are not conserved by the PDE.


It may arise the question if we can find conserved quantities, that are not preserved by the original PDE. Gerdt et al. [1] define the notion of s-consistency, which guarantees that all discrete quantities are also preserved in the continuous setting. One possible extension of the code would be to check if s-consistency holds for the translated scheme.
Concluding remarks.


We present an algorithm for checking the conservation of a quantity under a finite-difference scheme. Our algorithm allows for systems of equations, arbitrary time and space derivatives, and both explicit and implicit schemes. Also, we implemented a function for finding conserved quantities admitted by a scheme. We use our implementation of the algorithm to analyze the conservation properties of several schemes for PDEs that arise in applications. {  add remark on parametric groebner basis}


{splncs04}
{references}




\end{document}
